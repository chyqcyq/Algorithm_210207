# 第1次_2020_0214 [盛最多水的容器](https://leetcode-cn.com/problems/container-with-most-water/);
* 题目
给你 n 个非负整数 a1，a2，...，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0) 。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。
***
输入：height = [4,3,2,1,4]
输出：16
***
* 能想到的可能解法   
1. 暴力破解   
使用两个下标分别指向输入数组的相邻元素，然后通过两个循环，得到最大值
···
class Solution {
public:
    int maxArea(vector<int>& height) {
    int retVal = -1;
	int vectorSize = height.size();

	if(vectorSize == 0) {
		cout << "invaild vector size!" << endl;
		return retVal;
	}

	for(int i = 0; i < vectorSize-1; i++) {
		for(int j = i+1; j < vectorSize; j++) {
			int w = j - i;
			int h = (height[i] < height[j]) ? height[i] : height[j];
			retVal = retVal > (w*h) ? retVal : (w*h);
			cout << "maxVal = " << retVal << endl;
		}
	}
	

	return retVal;
    }
};
//时间复杂度 O(n^2)
//空间复杂度 O(n)
//运行结果：超出时间限制
···   
2. 双指针法
使用两个下标分别指向输入数组的头与尾，从题目上来看，横坐标肯定是越宽越好，但是纵坐标如果有更高的，横坐标也可以适当缩小。因此使用头尾双指针，使指向更低的指针向内侧移动，去找纵坐标更大的值，才有可能使面积最大。
···
class Solution {
public:
    int maxArea(vector<int>& height) {
    int retVal = -1;
	int vectorSize = height.size();

	if(vectorSize == 0) {
		cout << "invaild vector size!" << endl;
		return retVal;
	}

	for(int i = 0; i < vectorSize-1; i++) {
		for(int j = i+1; j < vectorSize; j++) {
			int w = j - i;
			int h = (height[i] < height[j]) ? height[i] : height[j];
			retVal = retVal > (w*h) ? retVal : (w*h);
			cout << "maxVal = " << retVal << endl;
		}
	}
	

	return retVal;
    }
};
//时间复杂度 O(n)
//空间复杂度 O(n)
//运行结果：
//执行用时：24 ms, 在所有 C++ 提交中击败了85.76%的用户
//内存消耗：17.2 MB, 在所有 C++ 提交中击败了93.99%的用户
···   
